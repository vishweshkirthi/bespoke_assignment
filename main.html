<!DOCTYPE html>
<html>
<head>
    <title>Document Quality Classifier</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .section { margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 5px; }
        .button { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
        .button:hover { background: #0056b3; }
        .button:disabled { background: #ccc; cursor: not-allowed; }
        .spinner { 
            border: 2px solid #f3f3f3; 
            border-top: 2px solid #ffffff; 
            border-radius: 50%; 
            width: 16px; 
            height: 16px; 
            animation: spin 1s linear infinite; 
            display: inline-block;
            margin-right: 8px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .result { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .high-quality { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .low-quality { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        textarea { width: 100%; height: 100px; margin: 10px 0; }
        input[type="file"] { margin: 10px 0; }
        .status { padding: 10px; margin: 10px 0; border-radius: 5px; }
        .status.loading { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .word-list { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
        .word-item { background: #e9ecef; color: #495057; padding: 6px 12px; border-radius: 15px; font-size: 14px; }
        .similarity-score { font-size: 12px; color: #6c757d; }
        .collapsible { cursor: pointer; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px; margin: 10px 0; }
        .collapsible:hover { background: #e9ecef; }
        .collapsible-content { display: none; padding: 15px; border: 1px solid #dee2e6; border-top: none; border-radius: 0 0 5px 5px; background: #fff; }
        .collapsible.active + .collapsible-content { display: block; }
        .param-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
        .param-item { display: flex; flex-direction: column; }
        .param-item label { font-weight: bold; margin-bottom: 5px; }
        .param-item input, .param-item select { padding: 5px; border: 1px solid #ced4da; border-radius: 3px; }
        .autotune-badge { background: #17a2b8; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px; }
    </style>
</head>
<body>
    <h1>Document Quality Classifier</h1>
    
    <div class="section">
        <h2>Model Management</h2>
        <div id="modelStatus">Checking...</div>
        
        <h3>Select Model</h3>
        <select id="modelSelect" style="width: 300px; padding: 8px; margin: 10px 0;">
            <option value="">Loading models...</option>
        </select>
        <button class="button" onclick="selectModel()" id="selectModelButton">Load Selected Model</button>
        <button class="button" onclick="refreshModels()" style="background: #6c757d;">Refresh Models</button>
        
        <div id="currentModelHyperparams" style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
            <h4>Current Model Hyperparameters</h4>
            <div id="modelHyperparamsContent">Loading...</div>
        </div>
    </div>
    
    <div class="section">
        <h2>Train Model</h2>
        <p><strong>Training file:</strong> Upload positive examples (format: __label__high [text]):</p>
        <input type="file" id="trainingFile" accept=".txt">
        
        <p><strong>Validation file (optional):</strong> Enable FastText autotune for hyperparameter optimization:</p>
        <input type="file" id="validationFile" accept=".txt">
        <label>
            <input type="checkbox" id="useAutotune"> Use autotune (takes longer but may improve accuracy)
        </label>
        <br><br>
        
        <div class="collapsible" onclick="toggleCollapsible(this)">
            <strong>⚙️ Hyperparameters</strong> <span style="font-size: 12px; color: #6c757d;">(click to expand)</span>
        </div>
        <div class="collapsible-content">
            <p style="color: #6c757d; font-size: 14px; margin-bottom: 15px;">
                Configure FastText training parameters. Default values are shown. Leave empty to use FastText defaults.
            </p>
            <div class="param-grid">
                <div class="param-item">
                    <label>Learning Rate (lr)</label>
                    <input type="number" id="lr" step="0.01" min="0.01" max="10" placeholder="0.1">
                </div>
                <div class="param-item">
                    <label>Dimensions (dim)</label>
                    <input type="number" id="dim" min="1" max="1000" placeholder="100">
                </div>
                <div class="param-item">
                    <label>Window Size (ws)</label>
                    <input type="number" id="ws" min="1" max="20" placeholder="5">
                </div>
                <div class="param-item">
                    <label>Epochs</label>
                    <input type="number" id="epoch" min="1" max="1000" placeholder="5">
                </div>
                <div class="param-item">
                    <label>Min N-gram (minn)</label>
                    <input type="number" id="minn" min="0" max="10" placeholder="3">
                </div>
                <div class="param-item">
                    <label>Max N-gram (maxn)</label>
                    <input type="number" id="maxn" min="0" max="10" placeholder="6">
                </div>
                <div class="param-item">
                    <label>Negative Sampling (neg)</label>
                    <input type="number" id="neg" min="1" max="100" placeholder="5">
                </div>
                <div class="param-item">
                    <label>Loss Function</label>
                    <select id="loss">
                        <option value="">Default (softmax)</option>
                        <option value="softmax">softmax (multiclass classification)</option>
                        <option value="ns">ns (negative sampling)</option>
                        <option value="hs">hs (hierarchical softmax)</option>
                        <option value="ova">ova (one-vs-all for multilabel)</option>
                    </select>
                </div>
                <div class="param-item">
                    <label>Model Type</label>
                    <select id="model">
                        <option value="">Default (supervised)</option>
                        <option value="cbow" disabled>cbow (unsupervised - not supported)</option>
                        <option value="skipgram" disabled>skipgram (unsupervised - not supported)</option>
                        <option value="supervised">supervised</option>
                    </select>
                </div>
                <div class="param-item">
                    <label>Buckets</label>
                    <input type="number" id="bucket" min="0" placeholder="2000000">
                </div>
                <div class="param-item">
                    <label>Min Count</label>
                    <input type="number" id="minCount" min="1" placeholder="1">
                </div>
                <div class="param-item">
                    <label>Thread Count</label>
                    <input type="number" id="thread" min="1" max="32" placeholder="12">
                </div>
            </div>
            <div style="margin-top: 15px;">
                <button type="button" class="button" style="background: #6c757d;" onclick="resetHyperparams()">Reset to Defaults</button>
            </div>
        </div>
        
        <button class="button" onclick="trainModel()" id="trainButton">Train Model</button>
        <div id="trainingInfo" style="display: none; margin-top: 10px; padding: 10px; background: #e8f4fd; border: 1px solid #b8daff; border-radius: 5px;">
            <div id="modelUUID"></div>
            <div id="trainingStatus"></div>
        </div>
    </div>
    
    <div class="section">
        <h2>Score Text</h2>
        
        <h3>Single Text Scoring</h3>
        <p><strong>Requirements:</strong> 50+ characters, minimum 10 words</p>
        <textarea id="textInput" placeholder="Enter text to score for quality... (minimum 50 characters, 10 words)"></textarea>
        <div id="textStats" style="font-size: 12px; color: #666; margin: 5px 0;">Characters: 0 | Words: 0</div>
        <button class="button" onclick="scoreText()" id="scoreButton">Score Text</button>
        <div id="scoreResult"></div>
        
        <h3>Batch Scoring</h3>
        <p>Upload a text file for batch scoring. Format: <code>__label__high [text]</code> or just <code>[text]</code></p>
        <input type="file" id="batchFile" accept=".txt" style="margin: 10px 0;">
        <button class="button" onclick="scoreBatch()" id="batchScoreButton">Score Batch File</button>
        <div id="batchResults"></div>
    </div>
    
    <div class="section">
        <h2>Find Similar Words</h2>
        <p>Find words similar to a given input using the trained FastText model</p>
        
        <div style="display: flex; gap: 10px; align-items: center; margin: 10px 0;">
            <input type="text" id="similarWordInput" placeholder="Enter a word..." style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
            <input type="number" id="similarWordCount" value="10" min="1" max="50" style="width: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 5px;" title="Number of similar words">
            <button class="button" onclick="findSimilarWords()" id="similarWordsButton">Find Similar</button>
        </div>
        
        <div id="similarWordsResult"></div>
        
        <div style="margin-top: 20px;">
            <h3>Model Vocabulary</h3>
            <div style="display: flex; gap: 10px; align-items: center; margin: 10px 0;">
                <button class="button" onclick="getVocabularyInfo()" id="vocabInfoButton" style="background: #6c757d;">Get Vocab Info</button>
                <button class="button" onclick="getVocabularySample()" id="vocabSampleButton" style="background: #17a2b8;">Sample Words</button>
            </div>
            <div id="vocabularyInfo"></div>
        </div>
    </div>
    
    <script>
        let socket = null;
        
        function connectWebSocket() {
            socket = new WebSocket('ws://localhost:8000/ws');
            
            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                updateTrainingProgress(data);
            };
            
            socket.onclose = function() {
                console.log('WebSocket connection closed');
            };
        }
        
        function updateTrainingProgress(status) {
            const trainButton = document.getElementById('trainButton');
            const trainingInfo = document.getElementById('trainingInfo');
            const modelUUID = document.getElementById('modelUUID');
            const trainingStatusDiv = document.getElementById('trainingStatus');
            
            if (status.is_training) {
                trainButton.disabled = true;
                trainButton.innerHTML = '<div class="spinner"></div>Training...';
                
                // Show training info
                trainingInfo.style.display = 'block';
                if (status.model_uuid) {
                    modelUUID.innerHTML = `<strong>Model UUID:</strong> ${status.model_uuid}`;
                }
                if (status.message) {
                    trainingStatusDiv.innerHTML = `<strong>Status:</strong> ${status.message}`;
                }
            } else {
                trainButton.disabled = false;
                trainButton.innerHTML = 'Train Model';
                
                if (status.progress === 100) {
                    // Training completed - auto-refresh models and auto-load the new model
                    refreshModels().then(() => {
                        // Auto-load the newly trained model
                        if (status.model_uuid) {
                            autoLoadNewModel(status.model_uuid);
                        }
                    });
                    
                    // Display final hyperparameters if available (especially for autotune)
                    if (status.hyperparams_used) {
                        displayHyperparams(status.hyperparams_used, status.autotune_used || false);
                    }
                    
                    setTimeout(() => {
                        trainingInfo.style.display = 'none';
                    }, 5000);
                }
            }
        }
        
        async function checkModelStatus() {
            try {
                const response = await fetch('/model/status');
                const data = await response.json();
                
                const statusDiv = document.getElementById('modelStatus');
                const hyperparamsDiv = document.getElementById('currentModelHyperparams');
                
                if (data.status === 'loaded') {
                    statusDiv.innerHTML = `<span class="status success">✓ Model loaded: ${data.model_name}</span>`;
                    
                    // Display hyperparameters if available
                    if (data.hyperparams) {
                        displayCurrentModelHyperparams(data.hyperparams);
                    } else {
                        document.getElementById('modelHyperparamsContent').innerHTML = '<p style="color: #6c757d;">No hyperparameters available - model may need to be reloaded.</p>';
                    }
                } else {
                    statusDiv.innerHTML = '<span class="status error">✗ No model loaded. Please train or select a model.</span>';
                    document.getElementById('modelHyperparamsContent').innerHTML = '<p style="color: #6c757d;">No model loaded. Please train or select a model to view hyperparameters.</p>';
                }
            } catch (error) {
                console.error('Error checking model status:', error);
                document.getElementById('modelStatus').innerHTML = '<span class="status error">Error checking status</span>';
                document.getElementById('modelHyperparamsContent').innerHTML = '<p style="color: #dc3545;">Error loading model status.</p>';
            }
        }
        
        async function refreshModels() {
            try {
                const response = await fetch('/models');
                const data = await response.json();
                
                const modelSelect = document.getElementById('modelSelect');
                modelSelect.innerHTML = '';
                
                if (data.models.length === 0) {
                    modelSelect.innerHTML = '<option value="">No models found</option>';
                    document.getElementById('selectModelButton').disabled = true;
                } else {
                    modelSelect.innerHTML = '<option value="">Select a model...</option>';
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = `${model.display_name} (${model.size_mb}MB) - ${model.created_at}`;
                        if (model.id === data.current_model) {
                            option.selected = true;
                            option.textContent += ' ★ CURRENT';
                        }
                        modelSelect.appendChild(option);
                    });
                    document.getElementById('selectModelButton').disabled = false;
                }
                
                return data; // Return the data for use in auto-loading
            } catch (error) {
                console.error('Error loading models:', error);
                document.getElementById('modelSelect').innerHTML = '<option value="">Error loading models</option>';
                throw error;
            }
        }
        
        async function autoLoadNewModel(modelUuid) {
            try {
                console.log(`Auto-loading newly trained model: ${modelUuid}`);
                
                // Find the model in the dropdown that contains this UUID
                const modelSelect = document.getElementById('modelSelect');
                let foundModelId = null;
                
                for (const option of modelSelect.options) {
                    if (option.value && option.value.includes(modelUuid.substring(0, 8))) {
                        foundModelId = option.value;
                        break;
                    }
                }
                
                if (foundModelId) {
                    // Select the model in the dropdown
                    modelSelect.value = foundModelId;
                    
                    // Automatically load the model
                    const response = await fetch('/model/select', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({model_id: foundModelId})
                    });
                    
                    if (response.ok) {
                        console.log(`Successfully auto-loaded model: ${foundModelId}`);
                        
                        // Refresh status to show the loaded model and hyperparameters
                        await checkModelStatus();
                        await refreshModels(); // Update the dropdown to show current model
                        
                        // Show a success message
                        const statusDiv = document.getElementById('modelStatus');
                        const originalContent = statusDiv.innerHTML;
                        statusDiv.innerHTML = '<span class="status success">✓ Newly trained model auto-loaded successfully!</span>';
                        setTimeout(() => {
                            checkModelStatus(); // Restore normal status
                        }, 3000);
                        
                    } else {
                        console.error('Failed to auto-load model');
                    }
                } else {
                    console.warn('Could not find newly trained model in dropdown');
                }
                
            } catch (error) {
                console.error('Error auto-loading model:', error);
            }
        }
        
        async function selectModel() {
            const modelSelect = document.getElementById('modelSelect');
            const selectedModel = modelSelect.value;
            
            if (!selectedModel) {
                alert('Please select a model');
                return;
            }
            
            const selectButton = document.getElementById('selectModelButton');
            selectButton.disabled = true;
            selectButton.innerHTML = '<div class="spinner"></div>Loading...';
            
            try {
                const response = await fetch('/model/select', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({model_id: selectedModel})
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Refresh status (which includes hyperparams) and models list
                    await checkModelStatus();
                    await refreshModels();
                    
                    alert(`Successfully loaded model: ${selectedModel}`);
                } else {
                    const error = await response.text();
                    alert(`Failed to load model: ${error}`);
                }
            } catch (error) {
                alert(`Error: ${error.message}`);
            } finally {
                selectButton.disabled = false;
                selectButton.innerHTML = 'Load Selected Model';
            }
        }
        
        async function trainModel() {
            const fileInput = document.getElementById('trainingFile');
            const validationFileInput = document.getElementById('validationFile');
            const useAutotuneCheckbox = document.getElementById('useAutotune');
            const trainButton = document.getElementById('trainButton');
            
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a training file');
                return;
            }
            
            // Show spinner immediately
            trainButton.disabled = true;
            trainButton.innerHTML = '<div class="spinner"></div>Training...';
            
            const formData = new FormData();
            formData.append('file', file);
            
            // Add validation file if autotune is enabled and file is selected
            if (useAutotuneCheckbox.checked) {
                const validationFile = validationFileInput.files[0];
                if (!validationFile) {
                    alert('Please select a validation file for autotune or uncheck the autotune option');
                    trainButton.disabled = false;
                    trainButton.innerHTML = 'Train Model';
                    return;
                }
                formData.append('validation_file', validationFile);
            }
            
            // Add hyperparameters
            const hyperparams = collectHyperparams();
            if (Object.keys(hyperparams).length > 0) {
                formData.append('hyperparams', JSON.stringify(hyperparams));
            }
            
            try {
                const response = await fetch('/train', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Show training info immediately
                    const trainingInfo = document.getElementById('trainingInfo');
                    const modelUUID = document.getElementById('modelUUID');
                    const trainingStatusDiv = document.getElementById('trainingStatus');
                    
                    trainingInfo.style.display = 'block';
                    modelUUID.innerHTML = `<strong>Model UUID:</strong> ${data.message.split('UUID: ')[1] || 'Generating...'}`;
                    trainingStatusDiv.innerHTML = `<strong>Status:</strong> Starting training with ${data.training_examples} examples...`;
                    
                    if (data.autotune_used) {
                        console.log('Using FastText autotune for hyperparameter optimization');
                    }
                    
                    // Display initial hyperparameters if provided
                    if (data.hyperparams_used) {
                        displayHyperparams(data.hyperparams_used, false);
                    }
                } else {
                    const error = await response.text();
                    alert('Training failed: ' + error);
                    // Reset button on error
                    trainButton.disabled = false;
                    trainButton.innerHTML = 'Train Model';
                }
            } catch (error) {
                alert('Error: ' + error.message);
                // Reset button on error
                trainButton.disabled = false;
                trainButton.innerHTML = 'Train Model';
            }
        }
        
        function updateTextStats() {
            const text = document.getElementById('textInput').value;
            const charCount = text.length;
            const wordCount = text.trim().split(/\s+/).filter(word => word.length > 0).length;
            
            const statsDiv = document.getElementById('textStats');
            const isValid = charCount >= 50 && wordCount >= 10;
            
            statsDiv.innerHTML = `Characters: ${charCount} | Words: ${wordCount}`;
            statsDiv.style.color = isValid ? '#28a745' : '#dc3545';
            
            const button = document.getElementById('scoreButton');
            button.disabled = !isValid || text.trim() === '';
        }
        
        async function scoreText() {
            const text = document.getElementById('textInput').value.trim();
            
            // Client-side validation
            if (!text) {
                alert('Please enter some text');
                return;
            }
            
            if (text.length < 50) {
                alert('Text must be at least 50 characters long');
                return;
            }
            
            const wordCount = text.split(/\s+/).filter(word => word.length > 0).length;
            if (wordCount < 10) {
                alert('Text must contain at least 10 words');
                return;
            }
            
            const button = document.getElementById('scoreButton');
            button.disabled = true;
            button.textContent = 'Scoring...';
            
            try {
                const response = await fetch('/score', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({text: text})
                });
                
                const resultDiv = document.getElementById('scoreResult');
                
                if (response.ok) {
                    const data = await response.json();
                    const qualityClass = data.is_high_quality ? 'high-quality' : 'low-quality';
                    const qualityText = data.is_high_quality ? 'HIGH QUALITY' : 'LOW QUALITY';
                    
                    resultDiv.innerHTML = `
                        <div class="result ${qualityClass}">
                            <strong>${qualityText}</strong><br>
                            Predicted: ${data.predicted_label}<br>
                            Confidence: ${(data.confidence * 100).toFixed(1)}%
                        </div>
                    `;
                } else {
                    const error = await response.text();
                    resultDiv.innerHTML = `<div class="result" style="background: #f8d7da; color: #721c24;">Error: ${error}</div>`;
                }
            } catch (error) {
                document.getElementById('scoreResult').innerHTML = `<div class="result" style="background: #f8d7da; color: #721c24;">Error: ${error.message}</div>`;
            } finally {
                button.disabled = false;
                button.textContent = 'Score Text';
            }
        }
        
        async function scoreBatch() {
            const fileInput = document.getElementById('batchFile');
            const file = fileInput.files[0];
            const button = document.getElementById('batchScoreButton');
            const resultsDiv = document.getElementById('batchResults');
            
            if (!file) {
                alert('Please select a file');
                return;
            }
            
            button.disabled = true;
            button.innerHTML = '<div class="spinner"></div>Scoring...';
            resultsDiv.innerHTML = '<div>Processing file...</div>';
            
            try {
                const formData = new FormData();
                formData.append('file', file);
                
                const response = await fetch('/score/batch', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const data = await response.json();
                    displayBatchResults(data);
                } else {
                    const error = await response.text();
                    resultsDiv.innerHTML = `<div style="background: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px;">Error: ${error}</div>`;
                }
            } catch (error) {
                resultsDiv.innerHTML = `<div style="background: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px;">Error: ${error.message}</div>`;
            } finally {
                button.disabled = false;
                button.innerHTML = 'Score Batch File';
            }
        }
        
        function displayBatchResults(data) {
            const resultsDiv = document.getElementById('batchResults');
            let html = '<div style="margin-top: 15px;">';
            
            // Summary
            html += `<h4>Batch Scoring Results</h4>`;
            html += `<p><strong>Total Documents:</strong> ${data.total_documents}</p>`;
            
            // Metrics if available
            if (data.metrics) {
                html += `<div style="background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 10px 0;">`;
                html += `<h4>Evaluation Metrics</h4>`;
                html += `<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">`;
                html += `<div><strong>Accuracy:</strong> ${(data.metrics.accuracy * 100).toFixed(1)}%</div>`;
                html += `<div><strong>Precision:</strong> ${(data.metrics.precision * 100).toFixed(1)}%</div>`;
                html += `<div><strong>Recall:</strong> ${(data.metrics.recall * 100).toFixed(1)}%</div>`;
                html += `<div><strong>F1-Score:</strong> ${(data.metrics.f1_score * 100).toFixed(1)}%</div>`;
                html += `</div>`;
                
                // Confusion Matrix
                const cm = data.metrics.confusion_matrix;
                html += `<div style="margin-top: 10px;">`;
                html += `<strong>Confusion Matrix:</strong>`;
                html += `<table style="border-collapse: collapse; margin: 5px 0;">`;
                html += `<tr><td></td><td style="padding: 5px; border: 1px solid #ccc;"><strong>Pred High</strong></td><td style="padding: 5px; border: 1px solid #ccc;"><strong>Pred Low</strong></td></tr>`;
                html += `<tr><td style="padding: 5px; border: 1px solid #ccc;"><strong>True High</strong></td><td style="padding: 5px; border: 1px solid #ccc;">${cm.tp}</td><td style="padding: 5px; border: 1px solid #ccc;">${cm.fn}</td></tr>`;
                html += `<tr><td style="padding: 5px; border: 1px solid #ccc;"><strong>True Low</strong></td><td style="padding: 5px; border: 1px solid #ccc;">${cm.fp}</td><td style="padding: 5px; border: 1px solid #ccc;">${cm.tn}</td></tr>`;
                html += `</table>`;
                html += `</div>`;
                html += `</div>`;
            }
            
            // Sample predictions by confusion matrix category (5 examples each)
            if (data.metrics && data.predictions.some(p => p.true_label)) {
                html += `<h4>Sample Predictions by Category (5 examples each)</h4>`;
                
                // Categorize predictions
                const categories = {
                    tp: [], // True Positive: predicted high, actually high
                    tn: [], // True Negative: predicted low, actually low
                    fp: [], // False Positive: predicted high, actually low
                    fn: []  // False Negative: predicted low, actually high
                };
                
                data.predictions.forEach(pred => {
                    if (pred.error || !pred.true_label) return;
                    
                    const predicted_high = pred.predicted_label === 'high' || pred.predicted_label === '__label__high';
                    const true_high = pred.true_label === 'high' || pred.true_label === '__label__high';
                    
                    // Debug logging for first few predictions
                    if (categories.tp.length + categories.tn.length + categories.fp.length + categories.fn.length < 5) {
                        console.log(`Pred: "${pred.predicted_label}", True: "${pred.true_label}", Pred_high: ${predicted_high}, True_high: ${true_high}`);
                    }
                    
                    if (predicted_high && true_high) {
                        categories.tp.push(pred);
                    } else if (!predicted_high && !true_high) {
                        categories.tn.push(pred);
                    } else if (predicted_high && !true_high) {
                        categories.fp.push(pred);
                    } else if (!predicted_high && true_high) {
                        categories.fn.push(pred);
                    }
                });
                
                // Debug: log category counts
                console.log('Category counts:', {
                    tp: categories.tp.length,
                    tn: categories.tn.length, 
                    fp: categories.fp.length,
                    fn: categories.fn.length
                });
                
                // Display each category
                const categoryLabels = {
                    tp: 'True Positives (Correctly predicted High Quality)',
                    tn: 'True Negatives (Correctly predicted Low Quality)',
                    fp: 'False Positives (Incorrectly predicted High Quality)',
                    fn: 'False Negatives (Incorrectly predicted Low Quality)'
                };
                
                const categoryColors = {
                    tp: { bg: '#d4edda', text: '#155724' },
                    tn: { bg: '#d4edda', text: '#155724' },
                    fp: { bg: '#f8d7da', text: '#721c24' },
                    fn: { bg: '#fff3cd', text: '#856404' }
                };
                
                Object.keys(categories).forEach(category => {
                    const samples = categories[category].slice(0, 5);
                    if (samples.length > 0) {
                        html += `<div style="margin: 15px 0;">`;
                        html += `<h5 style="margin-bottom: 10px;">${categoryLabels[category]} (${categories[category].length} total, showing ${samples.length})</h5>`;
                        
                        samples.forEach(pred => {
                            const colors = categoryColors[category];
                            html += `<div style="background: ${colors.bg}; color: ${colors.text}; padding: 10px; margin: 5px 0; border-radius: 5px; border-left: 4px solid ${colors.text};">`;
                            html += `<div><strong>Line ${pred.line_number}:</strong> `;
                            html += `${pred.predicted_label.toUpperCase()} (${(pred.confidence * 100).toFixed(1)}%) | True: ${pred.true_label.toUpperCase()}`;
                            html += `</div>`;
                            html += `<div style="font-size: 12px; margin-top: 5px;">${pred.text}</div>`;
                            html += `</div>`;
                        });
                        html += `</div>`;
                    }
                });
            } else {
                // Fallback to original display if no true labels
                html += `<h4>Sample Predictions (first 10)</h4>`;
                const samples = data.predictions.slice(0, 10);
                
                samples.forEach(pred => {
                    const bgColor = pred.error ? '#f8d7da' : 
                                   pred.is_high_quality ? '#d4edda' : '#fff3cd';
                    const textColor = pred.error ? '#721c24' : 
                                     pred.is_high_quality ? '#155724' : '#856404';
                    
                    html += `<div style="background: ${bgColor}; color: ${textColor}; padding: 10px; margin: 5px 0; border-radius: 5px;">`;
                    html += `<div><strong>Line ${pred.line_number}:</strong> `;
                    
                    if (pred.error) {
                        html += `ERROR - ${pred.error}`;
                    } else {
                        html += `${pred.predicted_label.toUpperCase()} (${(pred.confidence * 100).toFixed(1)}%)`;
                    }
                    html += `</div>`;
                    html += `<div style="font-size: 12px; margin-top: 5px;">${pred.text}</div>`;
                    html += `</div>`;
                });
                
                if (data.predictions.length > 10) {
                    html += `<p><em>... and ${data.predictions.length - 10} more results</em></p>`;
                }
            }
            
            html += '</div>';
            resultsDiv.innerHTML = html;
        }
        
        async function findSimilarWords() {
            const wordInput = document.getElementById('similarWordInput');
            const countInput = document.getElementById('similarWordCount');
            const button = document.getElementById('similarWordsButton');
            const resultDiv = document.getElementById('similarWordsResult');
            
            const word = wordInput.value.trim();
            const k = parseInt(countInput.value) || 10;
            
            if (!word) {
                alert('Please enter a word');
                return;
            }
            
            button.disabled = true;
            button.innerHTML = '<div class="spinner"></div>Finding...';
            resultDiv.innerHTML = '<div>Searching for similar words...</div>';
            
            try {
                const response = await fetch(`/similarity/${encodeURIComponent(word)}?k=${k}`);
                
                if (response.ok) {
                    const data = await response.json();
                    displaySimilarWords(data);
                } else {
                    const error = await response.text();
                    resultDiv.innerHTML = `<div style="background: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px;">Error: ${error}</div>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<div style="background: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px;">Error: ${error.message}</div>`;
            } finally {
                button.disabled = false;
                button.innerHTML = 'Find Similar';
            }
        }
        
        function displaySimilarWords(data) {
            const resultDiv = document.getElementById('similarWordsResult');
            
            if (data.neighbors.length === 0) {
                resultDiv.innerHTML = `<div style="background: #fff3cd; color: #856404; padding: 10px; border-radius: 5px;">No similar words found for "${data.word}"</div>`;
                return;
            }
            
            let html = `<div style="background: #d4edda; color: #155724; padding: 15px; border-radius: 5px;">`;
            html += `<h4>Similar words to "${data.word}" (${data.neighbors.length} results)</h4>`;
            html += `<div class="word-list">`;
            
            data.neighbors.forEach(([word, score]) => {
                const percentage = (score * 100).toFixed(1);
                html += `<div class="word-item">`;
                html += `<strong>${word}</strong><br>`;
                html += `<span class="similarity-score">${percentage}%</span>`;
                html += `</div>`;
            });
            
            html += `</div>`;
            html += `</div>`;
            
            resultDiv.innerHTML = html;
        }
        
        async function getVocabularyInfo() {
            const button = document.getElementById('vocabInfoButton');
            const resultDiv = document.getElementById('vocabularyInfo');
            
            button.disabled = true;
            button.innerHTML = '<div class="spinner"></div>Loading...';
            
            try {
                const response = await fetch('/model/vocabulary/size');
                
                if (response.ok) {
                    const data = await response.json();
                    resultDiv.innerHTML = `<div style="background: #e8f4fd; color: #0c5460; padding: 10px; border-radius: 5px;">
                        <strong>Vocabulary Size:</strong> ${data.vocabulary_size.toLocaleString()} words
                    </div>`;
                } else {
                    const error = await response.text();
                    resultDiv.innerHTML = `<div style="background: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px;">Error: ${error}</div>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<div style="background: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px;">Error: ${error.message}</div>`;
            } finally {
                button.disabled = false;
                button.innerHTML = 'Get Vocab Info';
            }
        }
        
        async function getVocabularySample() {
            const button = document.getElementById('vocabSampleButton');
            const resultDiv = document.getElementById('vocabularyInfo');
            
            button.disabled = true;
            button.innerHTML = '<div class="spinner"></div>Loading...';
            
            try {
                const response = await fetch('/model/vocabulary/sample?limit=30');
                
                if (response.ok) {
                    const data = await response.json();
                    
                    let html = `<div style="background: #e8f4fd; color: #0c5460; padding: 15px; border-radius: 5px;">`;
                    html += `<h4>Vocabulary Sample (${data.sample_size} of ${data.total_vocabulary_size.toLocaleString()} words)</h4>`;
                    html += `<div class="word-list">`;
                    
                    data.sample_words.forEach(word => {
                        html += `<div class="word-item" style="cursor: pointer;" onclick="document.getElementById('similarWordInput').value='${word}';">`;
                        html += `${word}`;
                        html += `</div>`;
                    });
                    
                    html += `</div>`;
                    html += `<p style="margin-top: 10px; font-size: 12px; color: #6c757d;">Click any word to search for similar words</p>`;
                    html += `</div>`;
                    
                    resultDiv.innerHTML = html;
                } else {
                    const error = await response.text();
                    resultDiv.innerHTML = `<div style="background: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px;">Error: ${error}</div>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<div style="background: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px;">Error: ${error.message}</div>`;
            } finally {
                button.disabled = false;
                button.innerHTML = 'Sample Words';
            }
        }
        
        // Add Enter key support for similar words input
        document.getElementById('similarWordInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                findSimilarWords();
            }
        });
        
        function toggleCollapsible(element) {
            element.classList.toggle('active');
        }
        
        function collectHyperparams() {
            const params = {};
            const paramIds = ['lr', 'dim', 'ws', 'epoch', 'minn', 'maxn', 'neg', 'loss', 'model', 'bucket', 'minCount', 'thread'];
            
            paramIds.forEach(id => {
                const element = document.getElementById(id);
                const value = element.value.trim();
                if (value) {
                    // Convert numeric values
                    if (element.type === 'number') {
                        params[id] = parseFloat(value);
                    } else {
                        params[id] = value;
                    }
                }
            });
            
            return params;
        }
        
        function resetHyperparams() {
            const paramIds = ['lr', 'dim', 'ws', 'epoch', 'minn', 'maxn', 'neg', 'loss', 'model', 'bucket', 'minCount', 'thread'];
            paramIds.forEach(id => {
                document.getElementById(id).value = '';
            });
        }
        
        function displayHyperparams(hyperparams, isAutotuned = false) {
            const paramContainer = document.getElementById('trainingStatus');
            if (!hyperparams) return;
            
            let html = '<div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">';
            html += '<h5>Used Hyperparameters';
            if (isAutotuned) {
                html += '<span class="autotune-badge">AUTOTUNED</span>';
            }
            html += '</h5>';
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px; font-size: 12px;">';
            
            Object.entries(hyperparams).forEach(([key, value]) => {
                html += `<div><strong>${key}:</strong> ${value}</div>`;
            });
            
            html += '</div></div>';
            paramContainer.innerHTML += html;
        }
        
        function displayCurrentModelHyperparams(hyperparams) {
            const container = document.getElementById('modelHyperparamsContent');
            if (!hyperparams) {
                container.innerHTML = '<p style="color: #6c757d;">Hyperparameters not available for this model.</p>';
                return;
            }
            
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; font-size: 14px;">';
            
            // Define friendly names and organize parameters
            const paramLabels = {
                lr: 'Learning Rate',
                dim: 'Dimensions',
                ws: 'Window Size', 
                epoch: 'Epochs',
                minn: 'Min N-gram',
                maxn: 'Max N-gram',
                neg: 'Negative Sampling',
                loss: 'Loss Function',
                bucket: 'Buckets',
                minCount: 'Min Count',
                thread: 'Threads'
            };
            
            Object.entries(hyperparams).forEach(([key, value]) => {
                const label = paramLabels[key] || key;
                html += `<div style="padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6;">`;
                html += `<div style="font-weight: bold; color: #495057;">${label}</div>`;
                html += `<div style="color: #007bff; font-family: monospace;">${value}</div>`;
                html += `</div>`;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        // Initialize
        connectWebSocket();
        checkModelStatus();
        refreshModels();
        
        // Add real-time text validation
        document.getElementById('textInput').addEventListener('input', updateTextStats);
        updateTextStats(); // Initial call
    </script>
</body>
</html>